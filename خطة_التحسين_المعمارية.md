# ğŸ“‹ Ø®Ø·Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© Ø§Ù„Ø´Ø§Ù…Ù„Ø©
## Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© ÙˆØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­Ø¶ÙˆØ± ÙˆØ§Ù„Ø§Ù†ØµØ±Ø§Ù

**ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ­Ù„ÙŠÙ„**: 2025-01-27  
**Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©**: 1.0 (Functional)  
**Ø§Ù„Ù‡Ø¯Ù**: Enterprise-Grade Architecture

---

## ğŸ“Š ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ

### âœ… Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚ÙˆØ©

1. **Ø§Ù„Ù…Ù†Ø·Ù‚ ØµØ­ÙŠØ­**: Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¯Ù‚ÙŠÙ‚Ø© ÙˆÙ…Ø·Ø¨Ù‚Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
2. **Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± Ø´Ø§Ù…Ù„Ø©**: ØªÙ‚Ø§Ø±ÙŠØ± Excel Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ø£ÙˆØ±Ø§Ù‚ Ù…Ø¹ ØªÙ†Ø³ÙŠÙ‚ Ø¹Ø±Ø¨ÙŠ
3. **Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø¹Ø±Ø¨ÙŠØ©**: ÙˆØ§Ø¬Ù‡Ø© Ù…Ø³ØªØ®Ø¯Ù… ÙƒØ§Ù…Ù„Ø© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
4. **Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª**: Ø¢Ù„ÙŠØ§Øª ØªØ­Ù‚Ù‚ Ù‚ÙˆÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„Ø­Ø³Ø§Ø¨
5. **Ø§Ù„ÙÙ„ØªØ±Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©**: Ø¥Ù…ÙƒØ§Ù†ÙŠØ§Øª ÙÙ„ØªØ±Ø© Ø´Ø§Ù…Ù„Ø©

### âŒ Ù†Ù‚Ø§Ø· Ø§Ù„Ø¶Ø¹Ù Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ©

1. **Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„Ù…ÙØ±Ø· Ø¹Ù„Ù‰ Pandas**: Ù…Ù†Ø·Ù‚ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„ Ù…ØªØ¯Ø§Ø®Ù„ Ù…Ø¹ DataFrame operations
2. **ØºÙŠØ§Ø¨ Domain Models**: Ù„Ø§ ØªÙˆØ¬Ø¯ Entities ØªÙ…Ø«Ù„ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
3. **Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Audit Trail**: Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø³Ø¬Ù„ ÙˆØ§Ø¶Ø­ Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª
4. **ØºÙŠØ§Ø¨ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª**: Ù„Ø§ ØªÙˆØ¬Ø¯ Unit Tests Ø£Ùˆ Integration Tests
5. **Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Composite Keys**: Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙØ§ØªÙŠØ­ Ù…Ù†Ø·Ù‚ÙŠØ© Ø±Ø³Ù…ÙŠØ©
6. **Ø§Ù„ØªÙˆØ«ÙŠÙ‚ ØºÙŠØ± ÙƒØ§ÙÙ**: Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ù…ÙˆØ«Ù‚Ø© Ù„ÙƒÙ† ØºÙŠØ± Ù…Ø­Ù…ÙŠØ© Ø¨Ø±Ù…Ø¬ÙŠØ§Ù‹

---

## ğŸ¯ Ø®Ø·Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ©

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù‡ÙŠÙƒÙ„Ø© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© (Architectural Refactoring)

#### 1.1 Ø¥Ù†Ø´Ø§Ø¡ Domain Layer

**Ø§Ù„Ù‡Ø¯Ù**: ÙØµÙ„ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„ Ø¹Ù† Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**:

```
domain/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ models.py          # Domain Entities
â”œâ”€â”€ value_objects.py   # Value Objects
â””â”€â”€ services.py        # Domain Services
```

**Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©**:

```python
# domain/models.py

from dataclasses import dataclass
from datetime import date, datetime
from typing import List, Optional
from enum import Enum

class DayStatus(Enum):
    """Ø­Ø§Ù„Ø© Ø§Ù„ÙŠÙˆÙ…"""
    COMPLETE = "Ù…Ø³ØªÙˆÙÙŠ"
    INCOMPLETE = "Ù†Ù‚Øµ Ø¨ØµÙ…Ø©"
    ABSENT = "ØºØ§Ø¦Ø¨"

@dataclass
class RequiredTime:
    """Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„Ø¨ØµÙ…Ø©"""
    time_str: str
    description: str
    hour: int
    minute: int
    
@dataclass
class Fingerprint:
    """Ø¨ØµÙ…Ø© ÙˆØ§Ø­Ø¯Ø©"""
    employee_name: str
    department: str
    date: date
    time: datetime
    normalized_time: str
    
@dataclass
class MatchedPunch:
    """Ø¨ØµÙ…Ø© Ù…Ø·Ø§Ø¨Ù‚Ø©"""
    required_time: RequiredTime
    actual_time: datetime
    delay_minutes: float
    is_late: bool  # True if delay > tolerance
    
@dataclass
class MissingPunch:
    """Ø¨ØµÙ…Ø© Ù…ÙÙ‚ÙˆØ¯Ø©"""
    required_time: RequiredTime
    tolerance_start: datetime
    tolerance_end: datetime

@dataclass
class AttendanceDay:
    """ÙƒÙŠØ§Ù† ÙŠÙˆÙ… Ø§Ù„Ø­Ø¶ÙˆØ± - Ø§Ù„ÙˆØ­Ø¯Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©"""
    employee_name: str
    department: str
    shift_date: date
    required_times: List[RequiredTime]
    matched_punches: List[MatchedPunch]
    missing_punches: List[MissingPunch]
    day_status: DayStatus
    actual_checks: int
    required_checks: int
    missing_checks: int
    late_count: int
    late_minutes: float
    compliance_rate: float
    
    def calculate_metrics(self):
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³"""
        self.actual_checks = len(self.matched_punches)
        self.required_checks = len(self.required_times)
        self.missing_checks = len(self.missing_punches)
        
        if self.required_checks > 0:
            self.compliance_rate = (self.actual_checks / self.required_checks) * 100
        else:
            self.compliance_rate = 0.0
            
        self.late_count = sum(1 for p in self.matched_punches if p.is_late)
        self.late_minutes = sum(p.delay_minutes for p in self.matched_punches if p.is_late)
        
    def determine_status(self) -> DayStatus:
        """ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©"""
        # Check if there are any punches on the shift day
        day_punches = [p for p in self.matched_punches 
                      if p.actual_time.date() == self.shift_date]
        
        if not day_punches:
            return DayStatus.ABSENT
        
        if self.actual_checks == self.required_checks:
            return DayStatus.COMPLETE
        else:
            return DayStatus.INCOMPLETE

@dataclass
class EmployeeSummary:
    """Ù…Ù„Ø®Øµ Ø§Ù„Ù…ÙˆØ¸Ù"""
    employee_name: str
    department: str
    total_working_days: int
    complete_days: int
    incomplete_days: int
    absent_days: int
    absence_reason: str
    late_count: int
    late_minutes: float
    required_checks: int
    actual_checks: int
    missing_checks: int
    compliance_rate: float
    final_status: str  # "Ù…Ù„ØªØ²Ù…" or "ØºÙŠØ± Ù…Ù„ØªØ²Ù…"
    
    @classmethod
    def from_daily_results(cls, employee_name: str, department: str, 
                          daily_results: List[AttendanceDay], 
                          absence_threshold: int) -> 'EmployeeSummary':
        """Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ø®Øµ Ù…Ù† Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ÙŠÙˆÙ…ÙŠØ©"""
        total_working_days = len(daily_results)
        complete_days = sum(1 for d in daily_results if d.day_status == DayStatus.COMPLETE)
        incomplete_days = sum(1 for d in daily_results if d.day_status == DayStatus.INCOMPLETE)
        
        # Calculate absent days from missing checks
        total_missing_checks = sum(d.missing_checks for d in daily_results)
        absent_days = total_missing_checks // absence_threshold
        
        # Create absence reason
        if total_missing_checks > 0:
            if absent_days > 0:
                absence_reason = f"Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ØµÙ…Ø§Øª Ø§Ù„Ù…ØªØ±ÙˆÙƒØ©: {total_missing_checks}ØŒ ÙƒÙ„ {absence_threshold} Ø¨ØµÙ…Ø© = ÙŠÙˆÙ… ØºÙŠØ§Ø¨"
            else:
                absence_reason = f"Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ØµÙ…Ø§Øª Ø§Ù„Ù…ØªØ±ÙˆÙƒØ©: {total_missing_checks} (Ø£Ù‚Ù„ Ù…Ù† Ø¹ØªØ¨Ø© Ø§Ù„ØºÙŠØ§Ø¨)"
        else:
            absence_reason = "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ØµÙ…Ø§Øª Ù…ØªØ±ÙˆÙƒØ©"
        
        total_late_count = sum(d.late_count for d in daily_results)
        total_late_minutes = sum(d.late_minutes for d in daily_results)
        total_required_checks = sum(d.required_checks for d in daily_results)
        total_actual_checks = sum(d.actual_checks for d in daily_results)
        
        if total_required_checks > 0:
            compliance_rate = (total_actual_checks / total_required_checks) * 100
        else:
            compliance_rate = 0.0
        
        final_status = "Ù…Ù„ØªØ²Ù…" if incomplete_days == 0 and absent_days == 0 else "ØºÙŠØ± Ù…Ù„ØªØ²Ù…"
        
        return cls(
            employee_name=employee_name,
            department=department,
            total_working_days=total_working_days,
            complete_days=complete_days,
            incomplete_days=incomplete_days,
            absent_days=absent_days,
            absence_reason=absence_reason,
            late_count=total_late_count,
            late_minutes=total_late_minutes,
            required_checks=total_required_checks,
            actual_checks=total_actual_checks,
            missing_checks=total_missing_checks,
            compliance_rate=compliance_rate,
            final_status=final_status
        )
```

**Ø§Ù„ÙÙˆØ§Ø¦Ø¯**:
- âœ… ÙØµÙ„ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„ Ø¹Ù† Pandas
- âœ… Ø³Ù‡ÙˆÙ„Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±
- âœ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
- âœ… ÙˆØ¶ÙˆØ­ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª

---

#### 1.2 Ø¥Ù†Ø´Ø§Ø¡ Service Layer

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**:

```
services/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ attendance_service.py    # Attendance Calculation Service
â”œâ”€â”€ fingerprint_matcher.py   # Fingerprint Matching Logic
â””â”€â”€ aggregation_service.py  # Aggregation Logic
```

**Ù…Ø«Ø§Ù„**:

```python
# services/attendance_service.py

from domain.models import AttendanceDay, EmployeeSummary, DayStatus
from domain.value_objects import RequiredTime, Fingerprint
from typing import List

class AttendanceService:
    """Ø®Ø¯Ù…Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¶ÙˆØ±"""
    
    def __init__(self, tolerance_minutes: int, absence_threshold: int):
        self.tolerance_minutes = tolerance_minutes
        self.absence_threshold = absence_threshold
        
    def calculate_day_attendance(
        self, 
        employee_name: str,
        department: str,
        shift_date: date,
        fingerprints: List[Fingerprint],
        required_times: List[RequiredTime]
    ) -> AttendanceDay:
        """Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¶ÙˆØ± Ù„ÙŠÙˆÙ… ÙˆØ§Ø­Ø¯"""
        # Match fingerprints to required times
        matched_punches, missing_punches = self._match_fingerprints(
            fingerprints, required_times, shift_date
        )
        
        # Create AttendanceDay
        attendance_day = AttendanceDay(
            employee_name=employee_name,
            department=department,
            shift_date=shift_date,
            required_times=required_times,
            matched_punches=matched_punches,
            missing_punches=missing_punches,
            day_status=DayStatus.COMPLETE,  # Will be determined
            actual_checks=0,
            required_checks=0,
            missing_checks=0,
            late_count=0,
            late_minutes=0.0,
            compliance_rate=0.0
        )
        
        # Calculate metrics and determine status
        attendance_day.calculate_metrics()
        attendance_day.day_status = attendance_day.determine_status()
        
        return attendance_day
    
    def aggregate_employee_results(
        self,
        daily_results: List[AttendanceDay]
    ) -> List[EmployeeSummary]:
        """ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„ÙƒÙ„ Ù…ÙˆØ¸Ù"""
        # Group by employee
        employees = {}
        for day in daily_results:
            key = (day.employee_name, day.department)
            if key not in employees:
                employees[key] = []
            employees[key].append(day)
        
        # Create summaries
        summaries = []
        for (name, dept), days in employees.items():
            summary = EmployeeSummary.from_daily_results(
                name, dept, days, self.absence_threshold
            )
            summaries.append(summary)
        
        return summaries
```

---

#### 1.3 Ø¥Ù†Ø´Ø§Ø¡ Data Access Layer

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**:

```
data/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ repositories.py      # Data Repositories
â”œâ”€â”€ mappers.py           # Domain â†” DataFrame Mappers
â””â”€â”€ validators.py        # Data Validation
```

**Ù…Ø«Ø§Ù„**:

```python
# data/mappers.py

import pandas as pd
from domain.models import Fingerprint, AttendanceDay, EmployeeSummary
from datetime import datetime

class FingerprintMapper:
    """ØªØ­ÙˆÙŠÙ„ DataFrame Ø¥Ù„Ù‰ Domain Objects"""
    
    @staticmethod
    def from_dataframe(df: pd.DataFrame) -> List[Fingerprint]:
        """ØªØ­ÙˆÙŠÙ„ DataFrame Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Fingerprint"""
        fingerprints = []
        for _, row in df.iterrows():
            fp = Fingerprint(
                employee_name=row['Name'],
                department=row['Department'],
                date=pd.to_datetime(row['Date']).date(),
                time=pd.to_datetime(f"{row['Date']} {row['Time']}"),
                normalized_time=row['Time']
            )
            fingerprints.append(fp)
        return fingerprints

class AttendanceDayMapper:
    """ØªØ­ÙˆÙŠÙ„ Domain Objects Ø¥Ù„Ù‰ DataFrame"""
    
    @staticmethod
    def to_dataframe(days: List[AttendanceDay]) -> pd.DataFrame:
        """ØªØ­ÙˆÙŠÙ„ Ù‚Ø§Ø¦Ù…Ø© AttendanceDay Ø¥Ù„Ù‰ DataFrame"""
        data = []
        for day in days:
            data.append({
                'Name': day.employee_name,
                'Department': day.department,
                'Date': day.shift_date,
                'Day Status': day.day_status.value,
                'Actual Checks': day.actual_checks,
                'Required Checks': day.required_checks,
                'Missing Checks': day.missing_checks,
                'LateCount': day.late_count,
                'LateMinutes': day.late_minutes,
                'Compliance Rate': day.compliance_rate
            })
        return pd.DataFrame(data)
```

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: Audit Trail & Traceability

#### 2.1 Ø¥Ù†Ø´Ø§Ø¡ Audit Log System

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**:

```
audit/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ audit_logger.py      # Audit Logger
â””â”€â”€ audit_models.py      # Audit Models
```

**Ù…Ø«Ø§Ù„**:

```python
# audit/audit_logger.py

from dataclasses import dataclass
from datetime import datetime
from typing import List, Dict, Any
from enum import Enum

class AuditEventType(Enum):
    """Ù†ÙˆØ¹ Ø­Ø¯Ø« Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚"""
    FINGERPRINT_MATCHED = "Ø¨ØµÙ…Ø©_Ù…Ø·Ø§Ø¨Ù‚Ø©"
    FINGERPRINT_MISSING = "Ø¨ØµÙ…Ø©_Ù…ÙÙ‚ÙˆØ¯Ø©"
    DAY_STATUS_DETERMINED = "ØªØ­Ø¯ÙŠØ¯_Ø§Ù„Ø­Ø§Ù„Ø©_Ø§Ù„ÙŠÙˆÙ…ÙŠØ©"
    ABSENCE_CALCULATED = "Ø­Ø³Ø§Ø¨_Ø§Ù„ØºÙŠØ§Ø¨"
    AGGREGATION_PERFORMED = "ØªØ¬Ù…ÙŠØ¹_Ø§Ù„Ù†ØªØ§Ø¦Ø¬"

@dataclass
class AuditEvent:
    """Ø­Ø¯Ø« ØªØ¯Ù‚ÙŠÙ‚"""
    event_type: AuditEventType
    timestamp: datetime
    employee_name: str
    date: date
    details: Dict[str, Any]
    decision: str
    reasoning: str

class AuditLogger:
    """Ù…Ø³Ø¬Ù„ Ø£Ø­Ø¯Ø§Ø« Ø§Ù„ØªØ¯Ù‚ÙŠÙ‚"""
    
    def __init__(self):
        self.events: List[AuditEvent] = []
    
    def log_fingerprint_match(
        self, 
        employee_name: str,
        date: date,
        required_time: str,
        actual_time: datetime,
        matched: bool,
        reasoning: str
    ):
        """ØªØ³Ø¬ÙŠÙ„ Ù…Ø·Ø§Ø¨Ù‚Ø© Ø¨ØµÙ…Ø©"""
        event = AuditEvent(
            event_type=AuditEventType.FINGERPRINT_MATCHED if matched else AuditEventType.FINGERPRINT_MISSING,
            timestamp=datetime.now(),
            employee_name=employee_name,
            date=date,
            details={
                'required_time': required_time,
                'actual_time': actual_time.isoformat() if matched else None,
                'matched': matched
            },
            decision="Ù…Ø·Ø§Ø¨Ù‚" if matched else "ØºÙŠØ± Ù…Ø·Ø§Ø¨Ù‚",
            reasoning=reasoning
        )
        self.events.append(event)
    
    def log_day_status(
        self,
        employee_name: str,
        date: date,
        status: str,
        reasoning: str
    ):
        """ØªØ³Ø¬ÙŠÙ„ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©"""
        event = AuditEvent(
            event_type=AuditEventType.DAY_STATUS_DETERMINED,
            timestamp=datetime.now(),
            employee_name=employee_name,
            date=date,
            details={'status': status},
            decision=status,
            reasoning=reasoning
        )
        self.events.append(event)
    
    def export_to_dataframe(self) -> pd.DataFrame:
        """ØªØµØ¯ÙŠØ± Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø¥Ù„Ù‰ DataFrame"""
        data = []
        for event in self.events:
            data.append({
                'Ù†ÙˆØ¹ Ø§Ù„Ø­Ø¯Ø«': event.event_type.value,
                'Ø§Ù„ÙˆÙ‚Øª': event.timestamp,
                'Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¸Ù': event.employee_name,
                'Ø§Ù„ØªØ§Ø±ÙŠØ®': event.date,
                'Ø§Ù„Ù‚Ø±Ø§Ø±': event.decision,
                'Ø§Ù„Ø³Ø¨Ø¨': event.reasoning,
                'Ø§Ù„ØªÙØ§ØµÙŠÙ„': str(event.details)
            })
        return pd.DataFrame(data)
```

---

#### 2.2 Ø¥Ø¶Ø§ÙØ© Decision Explanation Sheet

**Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨**: `report_generator.py`

```python
def _write_decision_explanation_sheet(self, writer, employee_summaries, audit_log):
    """Ø¥Ù†Ø´Ø§Ø¡ Ø´ÙŠØª ÙŠØ´Ø±Ø­ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª"""
    explanations = []
    
    for summary in employee_summaries:
        # Get audit events for this employee
        employee_events = [
            e for e in audit_log.events 
            if e.employee_name == summary.employee_name
        ]
        
        # Build explanation
        explanation = {
            'Ø§Ø³Ù… Ø§Ù„Ù…ÙˆØ¸Ù': summary.employee_name,
            'Ø§Ù„Ù‚Ø³Ù…': summary.department,
            'Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©': summary.final_status,
            'Ø³Ø¨Ø¨ Ø§Ù„ØªØµÙ†ÙŠÙ': self._explain_final_status(summary),
            'Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…Ø¤Ø«Ø±Ø©': self._explain_affecting_days(summary, employee_events),
            'Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ù…Ø·Ø¨Ù‚Ø©': self._explain_applied_rules(summary)
        }
        explanations.append(explanation)
    
    df = pd.DataFrame(explanations)
    df.to_excel(writer, sheet_name='Ø´Ø±Ø­ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª', index=False)
    
def _explain_final_status(self, summary: EmployeeSummary) -> str:
    """Ø´Ø±Ø­ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©"""
    if summary.final_status == "Ù…Ù„ØªØ²Ù…":
        return "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£ÙŠØ§Ù… Ù†Ù‚Øµ Ø£Ùˆ ØºÙŠØ§Ø¨"
    else:
        reasons = []
        if summary.incomplete_days > 0:
            reasons.append(f"{summary.incomplete_days} ÙŠÙˆÙ… Ù†Ù‚Øµ Ø¨ØµÙ…Ø©")
        if summary.absent_days > 0:
            reasons.append(f"{summary.absent_days} ÙŠÙˆÙ… ØºÙŠØ§Ø¨")
        return "Ø› ".join(reasons)
```

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: Composite Keys & Data Integrity

#### 3.1 Ø¥Ù†Ø´Ø§Ø¡ Key Management System

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**:

```
core/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ keys.py           # Composite Key Management
â””â”€â”€ constraints.py    # Data Constraints
```

**Ù…Ø«Ø§Ù„**:

```python
# core/keys.py

from dataclasses import dataclass
from typing import Hashable

@dataclass(frozen=True)
class EmployeeDateKey:
    """Ù…ÙØªØ§Ø­ Ù…Ø±ÙƒØ¨: Ù…ÙˆØ¸Ù + ØªØ§Ø±ÙŠØ®"""
    employee_name: str
    date: date
    
    def __str__(self):
        return f"{self.employee_name}_{self.date.isoformat()}"
    
    def __hash__(self):
        return hash((self.employee_name, self.date))
    
    def __eq__(self, other):
        if not isinstance(other, EmployeeDateKey):
            return False
        return self.employee_name == other.employee_name and self.date == other.date

@dataclass(frozen=True)
class FingerprintKey:
    """Ù…ÙØªØ§Ø­ Ø¨ØµÙ…Ø©: Ù…ÙˆØ¸Ù + ØªØ§Ø±ÙŠØ® + ÙˆÙ‚Øª"""
    employee_name: str
    date: date
    time: str  # HH:MM format
    
    def __str__(self):
        return f"{self.employee_name}_{self.date.isoformat()}_{self.time}"
    
    def __hash__(self):
        return hash((self.employee_name, self.date, self.time))
    
    def __eq__(self, other):
        if not isinstance(other, FingerprintKey):
            return False
        return (self.employee_name == other.employee_name and 
                self.date == other.date and 
                self.time == other.time)

class KeyValidator:
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­"""
    
    @staticmethod
    def validate_fingerprint_key(key: FingerprintKey) -> bool:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ù…ÙØªØ§Ø­ Ø§Ù„Ø¨ØµÙ…Ø©"""
        if not key.employee_name or not key.employee_name.strip():
            return False
        if not key.time or len(key.time.split(':')) != 2:
            return False
        return True
    
    @staticmethod
    def validate_employee_date_key(key: EmployeeDateKey) -> bool:
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ù…ÙØªØ§Ø­ Ù…ÙˆØ¸Ù-ØªØ§Ø±ÙŠØ®"""
        if not key.employee_name or not key.employee_name.strip():
            return False
        return True
```

---

#### 3.2 ØªØ·Ø¨ÙŠÙ‚ Keys ÙÙŠ Data Processing

**Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨**: `attendance_calculator.py`

```python
from core.keys import EmployeeDateKey, FingerprintKey, KeyValidator

def calculate_attendance(self, fingerprint_data, shift_data, settings=None):
    # ... existing code ...
    
    # Create composite keys for fingerprints
    fingerprint_keys = set()
    valid_fingerprints = []
    
    for _, row in fingerprint_data.iterrows():
        key = FingerprintKey(
            employee_name=row['Name'],
            date=pd.to_datetime(row['Date']).date(),
            time=str(row['Time'])
        )
        
        if KeyValidator.validate_fingerprint_key(key):
            if key not in fingerprint_keys:
                fingerprint_keys.add(key)
                valid_fingerprints.append(row)
            # Duplicate key - skip
        # Invalid key - skip
    
    fingerprint_data = pd.DataFrame(valid_fingerprints)
```

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4: Testing Infrastructure

#### 4.1 Ø¥Ù†Ø´Ø§Ø¡ Test Suite

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**:

```
tests/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ conftest.py           # Pytest Configuration
â”œâ”€â”€ test_domain_models.py
â”œâ”€â”€ test_attendance_service.py
â”œâ”€â”€ test_fingerprint_matcher.py
â”œâ”€â”€ test_scenarios.py     # Scenario-based Tests
â””â”€â”€ fixtures/
    â”œâ”€â”€ sample_fingerprints.py
    â””â”€â”€ sample_shifts.py
```

**Ù…Ø«Ø§Ù„**:

```python
# tests/test_scenarios.py

import pytest
from datetime import date, datetime
from domain.models import AttendanceDay, DayStatus, Fingerprint, RequiredTime
from services.attendance_service import AttendanceService

class TestScenario1_PerfectDay:
    """Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ 1: ÙŠÙˆÙ… Ù…Ø³ØªÙˆÙÙŠ ØªÙ…Ø§Ù…Ø§Ù‹"""
    
    def test_perfect_day(self):
        service = AttendanceService(tolerance_minutes=30, absence_threshold=3)
        
        fingerprints = [
            Fingerprint("Ø£Ø­Ù…Ø¯", "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", date(2025, 1, 15), 
                       datetime(2025, 1, 15, 8, 5), "08:05"),
            Fingerprint("Ø£Ø­Ù…Ø¯", "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", date(2025, 1, 15),
                       datetime(2025, 1, 15, 12, 0), "12:00"),
            # ... more fingerprints
        ]
        
        required_times = [
            RequiredTime("08:00", "Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¯ÙˆØ§Ù…", 8, 0),
            RequiredTime("12:00", "Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØµØ¨Ø§Ø­", 12, 0),
            # ... more times
        ]
        
        result = service.calculate_day_attendance(
            "Ø£Ø­Ù…Ø¯", "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", date(2025, 1, 15),
            fingerprints, required_times
        )
        
        assert result.day_status == DayStatus.COMPLETE
        assert result.actual_checks == len(required_times)
        assert result.missing_checks == 0
        assert result.compliance_rate == 100.0

class TestScenario2_AbsentDay:
    """Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ 2: ÙŠÙˆÙ… ØºØ§Ø¦Ø¨"""
    
    def test_absent_day(self):
        service = AttendanceService(tolerance_minutes=30, absence_threshold=3)
        
        fingerprints = []  # No fingerprints
        
        required_times = [
            RequiredTime("08:00", "Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¯ÙˆØ§Ù…", 8, 0),
            # ... more times
        ]
        
        result = service.calculate_day_attendance(
            "Ù…Ø­Ù…Ø¯", "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", date(2025, 1, 15),
            fingerprints, required_times
        )
        
        assert result.day_status == DayStatus.ABSENT
        assert result.actual_checks == 0
        assert result.missing_checks == len(required_times)

class TestScenario3_MissingPunches:
    """Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ 3: Ù†Ù‚Øµ Ø¨ØµÙ…Ø§Øª"""
    
    def test_missing_punches(self):
        service = AttendanceService(tolerance_minutes=30, absence_threshold=3)
        
        # Only 3 out of 4 required punches
        fingerprints = [
            Fingerprint("Ø¹Ù„ÙŠ", "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", date(2025, 1, 15),
                       datetime(2025, 1, 15, 8, 0), "08:00"),
            Fingerprint("Ø¹Ù„ÙŠ", "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", date(2025, 1, 15),
                       datetime(2025, 1, 15, 12, 0), "12:00"),
            Fingerprint("Ø¹Ù„ÙŠ", "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", date(2025, 1, 15),
                       datetime(2025, 1, 15, 15, 0), "15:00"),
        ]
        
        required_times = [
            RequiredTime("08:00", "Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø¯ÙˆØ§Ù…", 8, 0),
            RequiredTime("12:00", "Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ØµØ¨Ø§Ø­", 12, 0),
            RequiredTime("15:00", "Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙˆØ±Ø¯ÙŠØ©", 15, 0),
            RequiredTime("20:00", "Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙˆØ±Ø¯ÙŠØ©", 20, 0),
        ]
        
        result = service.calculate_day_attendance(
            "Ø¹Ù„ÙŠ", "Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", date(2025, 1, 15),
            fingerprints, required_times
        )
        
        assert result.day_status == DayStatus.INCOMPLETE
        assert result.actual_checks == 3
        assert result.missing_checks == 1
        assert result.compliance_rate == 75.0

class TestScenario4_AbsenceCalculation:
    """Ø§Ù„Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ 4: Ø­Ø³Ø§Ø¨ Ø§Ù„ØºÙŠØ§Ø¨ Ù…Ù† Ø§Ù„Ø¨ØµÙ…Ø§Øª Ø§Ù„Ù…ØªØ±ÙˆÙƒØ©"""
    
    def test_absence_calculation(self):
        service = AttendanceService(tolerance_minutes=30, absence_threshold=3)
        
        # Create 5 days with missing punches
        daily_results = []
        for i in range(5):
            day = AttendanceDay(
                employee_name="ÙØ§Ø·Ù…Ø©",
                department="Ø§Ù„Ù…Ø­Ø§Ø³Ø¨Ø©",
                shift_date=date(2025, 1, 15 + i),
                required_times=[],
                matched_punches=[],
                missing_punches=[],
                day_status=DayStatus.INCOMPLETE,
                actual_checks=3,
                required_checks=4,
                missing_checks=1,  # 1 missing per day
                late_count=0,
                late_minutes=0.0,
                compliance_rate=75.0
            )
            daily_results.append(day)
        
        summaries = service.aggregate_employee_results(daily_results)
        summary = summaries[0]
        
        # 5 missing checks total, threshold = 3
        # 5 // 3 = 1 absence day
        assert summary.absent_days == 1
        assert "Ø¹Ø¯Ø¯ Ø§Ù„Ø¨ØµÙ…Ø§Øª Ø§Ù„Ù…ØªØ±ÙˆÙƒØ©: 5" in summary.absence_reason
```

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 5: Documentation & Templates

#### 5.1 Ø¥Ù†Ø´Ø§Ø¡ CSV Templates Ø±Ø³Ù…ÙŠØ©

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**:

```
templates/
â”œâ”€â”€ employees_template.csv
â”œâ”€â”€ shifts_template.csv
â””â”€â”€ fingerprints_template.csv
```

**Ù…Ø«Ø§Ù„**:

```csv
# templates/fingerprints_template.csv
Name,Department,Date,Time
Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯,Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©,2025-01-15,08:00
Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯,Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©,2025-01-15,12:00
Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯,Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©,2025-01-15,15:00
Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯,Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©,2025-01-15,20:00
```

---

#### 5.2 Ø¥Ù†Ø´Ø§Ø¡ API Documentation

**Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**:

```
docs/
â”œâ”€â”€ api_reference.md
â”œâ”€â”€ architecture.md
â””â”€â”€ data_schema.md
```

---

## ğŸ“… Ø¬Ø¯ÙˆÙ„ Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ù‚ØªØ±Ø­

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù‡ÙŠÙƒÙ„Ø© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© (4-6 Ø£Ø³Ø§Ø¨ÙŠØ¹)

**Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 1-2**: Ø¥Ù†Ø´Ø§Ø¡ Domain Layer
- Ø¥Ù†Ø´Ø§Ø¡ `domain/models.py`
- Ø¥Ù†Ø´Ø§Ø¡ `domain/value_objects.py`
- ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¥Ù„Ù‰ Domain Objects

**Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 3-4**: Ø¥Ù†Ø´Ø§Ø¡ Service Layer
- Ø¥Ù†Ø´Ø§Ø¡ `services/attendance_service.py`
- Ø¥Ù†Ø´Ø§Ø¡ `services/fingerprint_matcher.py`
- Ø¥Ù†Ø´Ø§Ø¡ `services/aggregation_service.py`

**Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 5-6**: Ø¥Ù†Ø´Ø§Ø¡ Data Access Layer
- Ø¥Ù†Ø´Ø§Ø¡ `data/repositories.py`
- Ø¥Ù†Ø´Ø§Ø¡ `data/mappers.py`
- Ø±Ø¨Ø· Domain Layer Ø¨Ù€ Pandas

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: Audit Trail (2-3 Ø£Ø³Ø§Ø¨ÙŠØ¹)

**Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 1**: Ø¥Ù†Ø´Ø§Ø¡ Audit System
- Ø¥Ù†Ø´Ø§Ø¡ `audit/audit_logger.py`
- Ø¯Ù…Ø¬ Audit Logger ÙÙŠ Services

**Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 2**: Ø¥Ø¶Ø§ÙØ© Decision Explanation Sheet
- ØªØ¹Ø¯ÙŠÙ„ `report_generator.py`
- Ø¥Ø¶Ø§ÙØ© Ø´ÙŠØª "Ø´Ø±Ø­ Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª"

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: Composite Keys (1-2 Ø£Ø³Ø¨ÙˆØ¹)

**Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 1**: Ø¥Ù†Ø´Ø§Ø¡ Key Management
- Ø¥Ù†Ø´Ø§Ø¡ `core/keys.py`
- ØªØ·Ø¨ÙŠÙ‚ Keys ÙÙŠ Data Processing

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 4: Testing (3-4 Ø£Ø³Ø§Ø¨ÙŠØ¹)

**Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 1-2**: Ø¥Ù†Ø´Ø§Ø¡ Test Infrastructure
- Ø¥Ø¹Ø¯Ø§Ø¯ Pytest
- Ø¥Ù†Ø´Ø§Ø¡ Fixtures

**Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 3-4**: ÙƒØªØ§Ø¨Ø© Tests
- Unit Tests
- Integration Tests
- Scenario Tests

---

### Ø§Ù„Ù…Ø±Ø­Ù„Ø© 5: Documentation (1 Ø£Ø³Ø¨ÙˆØ¹)

**Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ 1**: Ø¥Ù†Ø´Ø§Ø¡ Templates Ùˆ Documentation
- CSV Templates
- API Documentation
- Architecture Documentation

---

## âš ï¸ Ø§Ù„Ù…Ø®Ø§Ø·Ø± ÙˆØ§Ù„Ø§Ø¹ØªØ¨Ø§Ø±Ø§Øª

### 1. Breaking Changes
- **Ø§Ù„Ù…Ø®Ø§Ø·Ø±**: Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© Ù‚Ø¯ ØªÙƒØ³Ø± Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ
- **Ø§Ù„Ø­Ù„**: ØªÙ†ÙÙŠØ° ØªØ¯Ø±ÙŠØ¬ÙŠ Ù…Ø¹ Backward Compatibility

### 2. Performance
- **Ø§Ù„Ù…Ø®Ø§Ø·Ø±**: Domain Objects Ù‚Ø¯ ØªÙƒÙˆÙ† Ø£Ø¨Ø·Ø£ Ù…Ù† Pandas
- **Ø§Ù„Ø­Ù„**: Profiling Ùˆ Optimization

### 3. Complexity
- **Ø§Ù„Ù…Ø®Ø§Ø·Ø±**: Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ Ù‚Ø¯ ØªØ¬Ø¹Ù„ Ø§Ù„ØµÙŠØ§Ù†Ø© Ø£ØµØ¹Ø¨
- **Ø§Ù„Ø­Ù„**: ØªÙˆØ«ÙŠÙ‚ Ø´Ø§Ù…Ù„ Ùˆ Code Reviews

---

## âœ… Ø§Ù„Ø®Ù„Ø§ØµØ©

### Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ
- âœ… **Functional**: Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
- âœ… **Accurate**: Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¯Ù‚ÙŠÙ‚Ø©
- âŒ **Not Enterprise-Grade**: ÙŠØ­ØªØ§Ø¬ ØªØ­Ø³ÙŠÙ†Ø§Øª Ù…Ø¹Ù…Ø§Ø±ÙŠØ©

### Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª
- âœ… **Enterprise-Grade Architecture**
- âœ… **Testable & Maintainable**
- âœ… **Auditable & Traceable**
- âœ… **Well-Documented**

---

## ğŸ¯ Ø§Ù„ØªÙˆØµÙŠØ©

**Ù†Ù‚ØªØ±Ø­ ØªÙ†ÙÙŠØ° Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¹Ù„Ù‰ Ù…Ø±Ø§Ø­Ù„**:

1. **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1 (Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ø¹Ø§Ù„ÙŠØ©)**: Domain Layer + Service Layer
2. **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2 (Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©)**: Audit Trail + Composite Keys
3. **Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3 (Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ù…Ù†Ø®ÙØ¶Ø©)**: Testing + Documentation

**Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù‚Ø¯Ø±**: 10-15 Ø£Ø³Ø¨ÙˆØ¹ Ø¹Ù…Ù„

**Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©**: 
- Ù…Ø·ÙˆØ± Python Ø®Ø¨ÙŠØ± (1 FTE)
- Code Reviewer (0.5 FTE)
- QA Engineer (0.5 FTE)

---

**ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯**: 2025-01-27  
**Ø§Ù„Ø¥ØµØ¯Ø§Ø±**: 1.0  
**Ø§Ù„Ø­Ø§Ù„Ø©**: âœ… Ø¬Ø§Ù‡Ø² Ù„Ù„ØªÙ†ÙÙŠØ°

